// Scanners/VulnerabilityScanner.cs
using System;
using System.Net.Sockets;
using System.Text;
using System.Threading.Tasks;
using System.Collections.Generic;
using System.Net.Security;
using System.Security.Cryptography.X509Certificates;
using System.Security.Authentication;
using PortScanner.Scanners.Common;

namespace PortScanner.Scanners
{
    public class VulnerabilityScanner
    {
        private static readonly VulnerabilityDatabase _vulnDb = new VulnerabilityDatabase();
        
        public static async Task<string> ScanForVulnerabilities(string host, int port, string detectedService)
        {
            StringBuilder resultsBuilder = new StringBuilder();

            try
            {
                if (string.IsNullOrEmpty(detectedService))
                {   
                    resultsBuilder.AppendLine($"Skipping vulnerability scan for port {port} - no service information available");
                    return resultsBuilder.ToString();
                }

                string serviceName = ExtractServiceName(port, detectedService);
                string version = ExtractVersion(port, detectedService);

                if (string.IsNullOrEmpty(serviceName) || string.IsNullOrEmpty(version))
                {
                    resultsBuilder.AppendLine($"Skipping vulnerability scan for port {port} - insufficient version information");
                    return resultsBuilder.ToString();
                }

                try
                {
                    var vulnerabilities = await _vulnDb.GetVulnerabilities(serviceName, version);

                    if (vulnerabilities != null && vulnerabilities.Any())
                    {
                        resultsBuilder.AppendLine($"VULNERABILITIES DETECTED:");
                        resultsBuilder.AppendLine($"Host: {host}:{port} ({detectedService})");
                        resultsBuilder.AppendLine(new string('-', 50));

                        foreach (var vuln in vulnerabilities.OrderByDescending(v => v.Severity))
                        {
                            resultsBuilder.AppendLine($"Severity: {vuln.Severity}");
                            resultsBuilder.AppendLine($"Name: {vuln.Name}");
                            resultsBuilder.AppendLine($"Description: {vuln.Description}");
                            if (!string.IsNullOrEmpty(vuln.CVE))
                            {
                                resultsBuilder.AppendLine($"CVE: {vuln.CVE}");
                            }
                            resultsBuilder.AppendLine($"Recommendation: {vuln.Recommendation}");
                            resultsBuilder.AppendLine(new string('-', 50));
                        }
                    }
                    else
                    {
                        resultsBuilder.AppendLine($"No vulnerabilities found for {host}:{port}.");
                    }
                }
                catch (Exception ex)
                {
                    resultsBuilder.AppendLine($"Error checking vulnerabilities: {ex.Message}");
                }
            }
            catch (Exception ex)
            {
                resultsBuilder.AppendLine($"Error during vulnerability scan: {ex.Message}");
                resultsBuilder.AppendLine("Continuing with port scanning...");
            }

            return resultsBuilder.ToString();
        }
        private static string ExtractServiceName(int port, string detectedService)
        {
            if (string.IsNullOrEmpty(detectedService))
                return null;

            // Map specific services based on port and detected service
            switch (port)
            {
                case 22 when detectedService.Contains("OpenSSH"):
                    return "openssh";
                case 23 when detectedService.Contains("telnetd"):
                    return "telnetd";
                case 25 when detectedService.Contains("Postfix"):
                    return "postfix";
                case 53 when detectedService.Contains("BIND"):
                    return "bind";
                case 80 when detectedService.Contains("Apache"):
                    return "apache";
                case 139:
                case 445 when detectedService.Contains("Samba"):
                    return "samba";
                case 512:
                case 513:
                case 514 when detectedService.Contains("netkit-rsh") ||
                            detectedService.Contains("rlogind") ||
                            detectedService.Contains("rshd"):
                    return "rsh-utils";
            }

            // General extraction for other services
            string serviceName = detectedService.Split(' ')[0].ToLower();
            serviceName = System.Text.RegularExpressions.Regex.Replace(serviceName, @"[^a-z0-9-]", "");
            return serviceName;
        }


        private static string ExtractVersion(int port, string detectedService)
        {
            if (string.IsNullOrEmpty(detectedService))
                return null;

            // Specific version extraction patterns based on service
            switch (port)
            {
                case 22 when detectedService.Contains("OpenSSH"): // OpenSSH_4.7p1
                    var sshMatch = System.Text.RegularExpressions.Regex.Match(detectedService, @"OpenSSH_(\d+\.\d+\w*\d*)");
                    return sshMatch.Success ? sshMatch.Groups[1].Value : null;

                case 23: // Linux telnetd
                    return "1.0"; // Generic version for basic telnet daemon

                case 25 when detectedService.Contains("Postfix"): // Postfix (Ubuntu)
                    var postfixMatch = System.Text.RegularExpressions.Regex.Match(detectedService, @"Postfix\s*[(\s]([^)\s]+)");
                    return postfixMatch.Success ? postfixMatch.Groups[1].Value : "2.0";

                case 53 when detectedService.Contains("BIND"): // ISC BIND 9.4.2
                    var bindMatch = System.Text.RegularExpressions.Regex.Match(detectedService, @"BIND\s+(\d+\.\d+\.\d+)");
                    return bindMatch.Success ? bindMatch.Groups[1].Value : null;

                case 80 when detectedService.Contains("Apache"): // Apache/2.2.8
                    var apacheMatch = System.Text.RegularExpressions.Regex.Match(detectedService, @"Apache/(\d+\.\d+\.\d+)");
                    return apacheMatch.Success ? apacheMatch.Groups[1].Value : null;

                case 139:
                case 445 when detectedService.Contains("Samba"): // Samba smbd 3.X - 4.X
                    var sambaMatch = System.Text.RegularExpressions.Regex.Match(detectedService, @"(\d+\.X)");
                    return sambaMatch.Success ? sambaMatch.Groups[1].Value : "3.0";

                case 512:
                case 513:
                case 514: // netkit-rsh services
                    return "1.0"; // Generic version for rsh utilities
            }

            // General version extraction for other services
            var versionMatch = System.Text.RegularExpressions.Regex.Match(
                detectedService,
                @"(?:version )?(\d+(?:\.\d+)+(?:-?\w*\d*)?)|(?:v(\d+(?:\.\d+)+(?:-?\w*\d*)?))|(?:/(\d+(?:\.\d+)+(?:-?\w*\d*)?))"
            );

            return versionMatch.Success ?
                (versionMatch.Groups[1].Value ?? versionMatch.Groups[2].Value ?? versionMatch.Groups[3].Value) :
                null;
        }
    }
}
using System.Net;
using Microsoft.Extensions.Logging;
using System.Text.RegularExpressions;
using System.Text.Json;
using gradproject.models;

namespace gradproject
{
    public class SmartVulnerabilityScanner
    {
        private readonly ILogger _logger;
        private readonly ServiceProber _prober;
        private readonly NVDService _nvdService;
        private readonly CPEDictionary _cpeDictionary;
        private Dictionary<string, List<CVEEntry>> _vulnerabilityCache = new();
        private readonly string _cacheFile;

        public SmartVulnerabilityScanner(ILogger logger, ServiceProber prober, string? nvdApiKey = null)
        {
            _logger = logger;
            _prober = prober;
            _nvdService = new NVDService(logger, nvdApiKey);
            _cpeDictionary = new CPEDictionary(logger);
            _cacheFile = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "vulnerability_cache.json");

            Task.Run(async () =>
            {
                try
                {
                    await LoadVulnerabilityCache();
                    _logger.LogInformation("Vulnerability cache loaded successfully");
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, "Failed to load vulnerability cache");
                }
            }).Wait();
        }

        public async Task<List<VulnerabilityResult>> ScanTarget(
            string host,
            IEnumerable<int> ports,
            IProgress<string>? progress = null,
            CancellationToken cancellationToken = default)
        {
            var results = new List<VulnerabilityResult>();
            progress?.Report($"Starting vulnerability scan on {host}");

            var scanner = new PortScannerc(
                new ScannerConfiguration
                {
                    MaxConcurrentScans = 100,
                    ConnectionTimeout = 5000,
                    BatchSize = 50,
                    EnableDebugLogging = false,
                    RetryAttempts = 3,
                    RetryDelay = 1000
                },
                _logger
            );

            var scanResults = await scanner.ScanAsync(host, ports, _prober, progress, cancellationToken);

            foreach (var port in scanResults.Where(r => r.IsOpen))
            {
                progress?.Report($"Checking vulnerabilities for {port.ServiceName} on port {port.Port}");

                try
                {
                    var (vendor, product, version) = ParseServiceInfo(port.ServiceName, port.ServiceBanner);
                    if (string.IsNullOrEmpty(product)) continue;

                    var cpeName = BuildCPEName(vendor, product, version);
                    if (string.IsNullOrEmpty(cpeName)) continue;

                    List<CVEEntry> vulnerabilities;
                    if (!_vulnerabilityCache.TryGetValue(cpeName, out vulnerabilities!))
                    {
                        try
                        {
                            vulnerabilities = await _nvdService.SearchVulnerabilities(cpeName);
                            if (vulnerabilities != null && vulnerabilities.Any())
                            {
                                _vulnerabilityCache[cpeName] = vulnerabilities;
                                await SaveVulnerabilityCache().ConfigureAwait(false);
                                _logger.LogInformation("New vulnerabilities found and cached for {CpeName}", cpeName);
                            }
                        }
                        catch (Exception ex)
                        {
                            _logger.LogError(ex, "Error fetching vulnerabilities for {CpeName}", cpeName);
                            continue;
                        }
                    }

                    foreach (var vuln in vulnerabilities)
                    {
                        if (IsVersionAffected(version, vuln.AffectedVersions))
                        {
                            results.Add(new VulnerabilityResult
                            {
                                Name = vuln.Name,
                                CVE = vuln.CVE,
                                IsVulnerable = true,
                                Severity = vuln.Severity,
                                Description = vuln.Description,
                                AffectedService = port.ServiceName,
                                AffectedVersion = version,
                                Recommendation = vuln.Recommendation,
                                References = vuln.References
                            });
                        }
                    }
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, "Error checking vulnerabilities for service {Service} on port {Port}",
                        port.ServiceName, port.Port);
                }
            }

            return results;
        }

        private (string vendor, string product, string version) ParseServiceInfo(string serviceInfo, string banner)
        {
            try
            {
                var patterns = new[]
                {
                    @"([a-zA-Z0-9._-]+)(?:/| )([\d.]+)",
                    @"([a-zA-Z0-9._-]+)"
                };

                foreach (var pattern in patterns)
                {
                    var match = Regex.Match(serviceInfo, pattern, RegexOptions.IgnoreCase);
                    if (match.Success)
                    {
                        var product = match.Groups[1].Value;
                        var version = match.Groups.Count > 2 ? match.Groups[2].Value : string.Empty;
                        var (vendor, mappedProduct) = _cpeDictionary.GetCPEMapping(product, banner);
                        return (vendor, mappedProduct, version);
                    }
                }

                // If no match found, try to get mapping directly from service name
                var (defaultVendor, defaultProduct) = _cpeDictionary.GetCPEMapping(serviceInfo, banner);
                return (defaultVendor, defaultProduct, string.Empty);
            }
            catch (Exception ex)
            {
                _logger.LogWarning(ex, "Error parsing service info: {ServiceInfo}", serviceInfo);
                return (string.Empty, string.Empty, string.Empty);
            }
        }

        private string BuildCPEName(string vendor, string product, string version)
        {
            if (string.IsNullOrEmpty(product)) return string.Empty;

            vendor = Regex.Replace(vendor, @"[^a-zA-Z0-9._-]", "_").ToLower();
            product = Regex.Replace(product, @"[^a-zA-Z0-9._-]", "_").ToLower();
            version = !string.IsNullOrEmpty(version) ?
                Regex.Replace(version, @"[^a-zA-Z0-9._-]", "_") : "*";

            return $"cpe:2.3:a:{vendor}:{product}:{version}:*:*:*:*:*:*:*";
        }

        private bool IsVersionAffected(string currentVersion, string[] affectedVersions)
        {
            if (string.IsNullOrWhiteSpace(currentVersion)) return false;

            var normalizedCurrent = NormalizeVersion(currentVersion);
            if (string.IsNullOrWhiteSpace(normalizedCurrent)) return false;

            foreach (var affectedVersion in affectedVersions)
            {
                var normalizedAffected = NormalizeVersion(affectedVersion);
                if (!string.IsNullOrWhiteSpace(normalizedAffected) &&
                    IsVersionInRange(normalizedCurrent, normalizedAffected))
                {
                    return true;
                }
            }

            return false;
        }

        private string NormalizeVersion(string version)
        {
            var match = Regex.Match(version, @"(\d+\.?)+");
            return match.Success ? match.Value : version;
        }

        private bool IsVersionInRange(string version, string affectedVersion)
        {
            try
            {
                if (Version.TryParse(version, out Version? ver1) &&
                    Version.TryParse(affectedVersion, out Version? ver2))
                {
                    return ver1 >= ver2;
                }
                return version.StartsWith(affectedVersion, StringComparison.OrdinalIgnoreCase);
            }
            catch
            {
                return version.StartsWith(affectedVersion, StringComparison.OrdinalIgnoreCase);
            }
        }

        private async Task SaveVulnerabilityCache()
        {
            try
            {
                var options = new JsonSerializerOptions { WriteIndented = true };
                await File.WriteAllTextAsync(_cacheFile,
                    JsonSerializer.Serialize(_vulnerabilityCache, options));
                _logger.LogDebug("Vulnerability cache saved successfully");
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error saving vulnerability cache");
            }
        }

        private async Task LoadVulnerabilityCache()
        {
            try
            {
                if (File.Exists(_cacheFile))
                {
                    var content = await File.ReadAllTextAsync(_cacheFile);
                    var cached = JsonSerializer.Deserialize<Dictionary<string, List<CVEEntry>>>(
                        content,
                        new JsonSerializerOptions { PropertyNameCaseInsensitive = true }
                    );

                    if (cached != null)
                    {
                        _vulnerabilityCache = cached;
                        _logger.LogInformation($"Loaded {cached.Count} vulnerability entries from cache");
                    }
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error loading vulnerability cache");
                _vulnerabilityCache = new Dictionary<string, List<CVEEntry>>();
            }
        }
    }
}